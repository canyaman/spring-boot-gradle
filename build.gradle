apply from: './version.gradle'

buildscript {
    ext {
        kotlinVersion = '1.3.31'
        springBootVersion = '2.1.4.RELEASE'
        springCloudVersion = 'Greenwich.SR1'
        springVerifierVersion = '2.1.1.RELEASE'

        springfoxSwaggerVersion = '2.9.2'

        ktlintVersion = '0.29.0'
        dockerGradleVersion = '0.20.1'
        gitGradleVersion = '2.0.0'
        springMockkVersion = '1.1.1'
        kotlinMockkVersion = '1.9.1'
        javaFakerVersion = '0.17.2'
    }
    repositories {
        mavenCentral()
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }
    dependencies {
        // Spring Boot
        classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
        // Kotlin Language
        classpath("org.jetbrains.kotlin:kotlin-gradle-plugin:${kotlinVersion}")
        // DI support
        classpath("org.jetbrains.kotlin:kotlin-allopen:${kotlinVersion}")
        // Docker
        classpath("gradle.plugin.com.palantir.gradle.docker:gradle-docker:${dockerGradleVersion}")
        // Git
        classpath("gradle.plugin.com.gorylenko.gradle-git-properties:gradle-git-properties:${gitGradleVersion}")
        // Cloud Contract
        classpath("org.springframework.cloud:spring-cloud-contract-gradle-plugin:${springVerifierVersion}")
    }
}

apply plugin: 'idea'
apply plugin: 'kotlin'
apply plugin: 'groovy'
apply plugin: 'kotlin-spring'
apply plugin: 'maven-publish'
apply plugin: 'org.springframework.boot'
apply plugin: 'io.spring.dependency-management'
apply plugin: 'spring-cloud-contract'
apply plugin: 'com.palantir.docker'
apply plugin: "com.gorylenko.gradle-git-properties"

group = projectGroup
version = projectVersion

sourceCompatibility = 1.8

compileKotlin {
    kotlinOptions {
        freeCompilerArgs = ["-Xjsr305=strict"]
        jvmTarget = "1.8"
    }
}

compileTestKotlin {
    kotlinOptions {
        freeCompilerArgs = ["-Xjsr305=strict"]
        jvmTarget = "1.8"
    }
}

sourceSets {
    test.java.srcDirs += new File(project.buildDir, "generated-test-source").toString()
}

compileTestGroovy.enabled = false

repositories {
    if (project.hasProperty("AWS_REPO_URL")) {
        maven {
            url AWS_REPO_URL
            credentials(AwsCredentials) {
                accessKey AWS_REPO_USER_ACCESS_KEY
                secretKey AWS_REPO_USER_SECRET_KEY
            }
        }
    }
    mavenLocal()
    mavenCentral()
    jcenter()
    maven { url "https://repo.spring.io/milestone" }
}

configurations {
    formattingOnly
    developmentOnly
    runtimeClasspath {
        extendsFrom developmentOnly
    }
}

allOpen {
    annotations("org.springframework.context.annotation.Configuration",
            "org.springframework.boot.autoconfigure.EnableAutoConfiguration")
}

dependencies {
    implementation platform("org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}")
    implementation platform("org.springframework.cloud:spring-cloud-contract-dependencies:${springVerifierVersion}")

    // Spring Boot
    implementation('org.springframework.boot:spring-boot-starter-actuator')
    implementation('org.springframework.boot:spring-boot-starter-data-rest')

    // Spring Cloud
    implementation("org.springframework.cloud:spring-cloud-starter-sleuth")
    implementation("org.springframework.cloud:spring-cloud-starter-openfeign")

    // Kotlin Support
    implementation('org.jetbrains.kotlin:kotlin-stdlib-jdk8')
    implementation('org.jetbrains.kotlin:kotlin-reflect')

    // Kotlin 1.3 reflection support
    implementation('com.fasterxml.jackson.module:jackson-module-kotlin')
    implementation('com.fasterxml.jackson.datatype:jackson-datatype-jsr310')

    // Swagger support
    implementation("io.springfox:springfox-swagger-ui:${springfoxSwaggerVersion}")
    implementation("io.springfox:springfox-swagger2:${springfoxSwaggerVersion}")
    implementation("io.springfox:springfox-data-rest:${springfoxSwaggerVersion}")

    // Metric
    implementation("io.micrometer:micrometer-registry-prometheus")

    // Lint
    formattingOnly("com.github.shyiko:ktlint:${ktlintVersion}")

     // Test
    testImplementation('org.springframework.boot:spring-boot-starter-test'){
        exclude group: 'junit', module: 'junit'
    }
    testImplementation('org.springframework.cloud:spring-cloud-starter-contract-verifier')
    testImplementation('org.springframework.cloud:spring-cloud-starter-contract-stub-runner')
    testImplementation('org.springframework.cloud:spring-cloud-contract-wiremock')

    // JUnit5
    testImplementation("org.junit.jupiter:junit-jupiter-api")
    testImplementation("org.junit.jupiter:junit-jupiter-params")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine")
    testRuntimeOnly("org.junit.platform:junit-platform-launcher")

    // Mock
    testImplementation("com.ninja-squad:springmockk:${springMockkVersion}")
    testImplementation("io.mockk:mockk:${kotlinMockkVersion}")

    // Fake
    testImplementation("com.github.javafaker:javafaker:${javaFakerVersion}"){
        exclude group: 'org.yaml', module: 'snakeyaml'
    }            

    // Dev Tool
    developmentOnly('org.springframework.boot:spring-boot-devtools')
}

springBoot {
    // This statement tells the Gradle Spring Boot plugin
    // to generate a file
    // build/resources/main/META-INF/build-info.properties
    // that is picked up by Spring Boot to display
    // via /actuator/info endpoint.
    // via /system/info endpoint.
    buildInfo {
        properties {
            additional = [
                    build                : System.properties['BUILD'] ?: '0',
                    basePackage          : projectBasePackage,
                    by                   : System.properties['user.name'],
                    operatingSystem      : "${System.properties['os.name']} (${System.properties['os.version']})",
                    continuousIntegration: System.getenv('CI') ? true : false,
                    machine              : InetAddress.localHost.hostName
            ]
        }
    }
}


test {
    useJUnitPlatform()
    minHeapSize = "512m"
    maxHeapSize = '1G'
}

task ktlint(type: JavaExec, group: "verification") {
    description = "Check Kotlin code style."
    classpath = configurations.formattingOnly
    main = "com.github.shyiko.ktlint.Main"
    args "src/**/*.kt"
    // to generate report in checkstyle format prepend following args:
    // "--reporter=plain", "--reporter=checkstyle,output=${buildDir}/ktlint.xml"
    // see https://github.com/shyiko/ktlint#usage for more
}
check.dependsOn ktlint

task ktlintFormat(type: JavaExec, group: "formatting") {
    description = "Fix Kotlin code style deviations."
    classpath = configurations.formattingOnly
    main = "com.github.shyiko.ktlint.Main"
    args "-F", "src/**/*.kt"
}

docker {
    dependsOn build
    if (project.version ==~ /\d+.\d+.\d+/) {
        name "${project.group}/${bootJar.baseName}:${project.version}"
    } else {
        name "${project.group}/${bootJar.baseName}"
    }
    tags 'latest'
    files bootJar.archivePath
    buildArgs(['JAR_FILE': "${bootJar.archiveName}"])
}

task generateBuildProperties() {
    dependsOn bootBuildInfo
    dependsOn generateGitProperties

    def bootBuildInfoPropertiesFile = "$buildDir/resources/main/META-INF/build-info.properties"
    def bootBuildGitPropertiesFile = "$buildDir/resources/main/git.properties"

    def propertiesDir = "$buildDir/properties"
    def propertiesFolder = new File(propertiesDir)
    propertiesFolder.mkdirs()

    def gradlePropertiesFilePath = "$propertiesDir/build-gradle.properties"
    def buildPropertiesFilePath = "$propertiesDir/build-info.properties"
    def gitPropertiesFilePath = "$propertiesDir/build-git.properties"

    inputs.files(bootBuildInfoPropertiesFile, bootBuildGitPropertiesFile)
    outputs.files(gradlePropertiesFilePath, buildPropertiesFilePath, gitPropertiesFilePath)

    doLast {
        def prefix = "APP_"
        def commentMessage = "This is autogenerated build property"

        ant.propertyfile(file: "$gradlePropertiesFilePath", comment: commentMessage) {
            entry(key: prefix + "version".toUpperCase(Locale.ENGLISH).replace('.', '_'), value: "\"${projectVersion}\"")
            entry(key: prefix + "name".toUpperCase(Locale.ENGLISH).replace('.', '_'), value: "\"${projectName}\"")
        }
        println "Build gradle properties stored at $gradlePropertiesFilePath "
        logger.info("Build gradle properties stored at {} exist {}", "$gradlePropertiesFilePath", file(gradlePropertiesFilePath).exists())

        def buildProps = new Properties()
        ant.propertyfile(file: "$buildPropertiesFilePath", comment: commentMessage) {
            file("$bootBuildInfoPropertiesFile").withInputStream { stream -> buildProps.load(stream) }
            buildProps.each { key, val ->
                entry(key: prefix + key.toUpperCase(Locale.ENGLISH).replace('.', '_'), value: "\"${val}\"")
            }
        }

        println "Build info properties stored at $buildPropertiesFilePath "
        logger.info("Build info properties stored at {} exist {}", "$buildPropertiesFilePath", file(buildPropertiesFilePath).exists())

        def gitProps = new Properties()
        ant.propertyfile(file: "$gitPropertiesFilePath", comment: commentMessage) {
            file("$bootBuildGitPropertiesFile").withInputStream { stream -> gitProps.load(stream) }
            gitProps.each { key, val ->
                entry(key: prefix + key.toUpperCase(Locale.ENGLISH).replace('.', '_'), value: "\"${val}\"")
            }
        }
        println "Build git properties stored at $gitPropertiesFilePath "
        logger.info("Build git properties stored at {} exist {}", "$gitPropertiesFilePath", file(gitPropertiesFilePath).exists())
    }
}

publishing {
    publications {
        maven(MavenPublication) {
            groupId = projectGroup
            artifactId = projectName
            version = projectVersion

            repositories {
                if (project.hasProperty("AWS_REPO_URL")) {
                    maven {
                        url AWS_REPO_URL
                        credentials(AwsCredentials) {
                            accessKey AWS_REPO_ADMIN_ACCESS_KEY
                            secretKey AWS_REPO_ADMIN_SECRET_KEY
                        }
                    }
                }
            }
        }
    }
}

task showRepositories {
    doLast {
        repositories.each {
            println "repository: ${it.name} ('${it.url}')"
        }
    }
}